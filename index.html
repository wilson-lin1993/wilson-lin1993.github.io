<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>Wilson</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Wilson">
<meta property="og:url" content="wilson-lin1993.github.io/index.html">
<meta property="og:site_name" content="Wilson">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wilson">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Wilson" rel="home">Wilson</a>
      </h1>
      

      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-react源码阅读" class="post-react源码阅读 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/02/21/react源码阅读/">react源码阅读</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="wilson-lin1993.github.io/2017/02/21/react源码阅读/" data-id="cizggy3ps0002cve8htgs10e6" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="version-16-0-0-alpha-2"><a href="#version-16-0-0-alpha-2" class="headerlink" title="version: 16.0.0-alpha.2"></a>version: 16.0.0-alpha.2</h1><h1 id="ReactComponent-src-iscomorphic-modern-class-ReactBaseClasses-js"><a href="#ReactComponent-src-iscomorphic-modern-class-ReactBaseClasses-js" class="headerlink" title="ReactComponent(./src/iscomorphic/modern/class/ReactBaseClasses.js)"></a>ReactComponent(./src/iscomorphic/modern/class/ReactBaseClasses.js)</h1><pre><code>constructor(props, context, updater)
    this.refs = emptyObject
</code></pre><h1 id="ReactElement-src-isomorphic-classic-element-ReactElement-js"><a href="#ReactElement-src-isomorphic-classic-element-ReactElement-js" class="headerlink" title="ReactElement(./src/isomorphic/classic/element/ReactElement.js)"></a>ReactElement(./src/isomorphic/classic/element/ReactElement.js)</h1><pre><code>createElement
==
</code></pre><h1 id="ReactDom-src-renderers-ReactDOM-js"><a href="#ReactDom-src-renderers-ReactDOM-js" class="headerlink" title="ReactDom(./src/renderers/ReactDOM.js)"></a>ReactDom(./src/renderers/ReactDOM.js)</h1><h1 id="ReactMount-src-renderers-dom-stack-client-ReactMount-js"><a href="#ReactMount-src-renderers-dom-stack-client-ReactMount-js" class="headerlink" title="ReactMount(./src/renderers/dom/stack/client/ReactMount.js)"></a>ReactMount(./src/renderers/dom/stack/client/ReactMount.js)</h1><pre><code>render:
    return ReactMount._renderSubtreeIntoContainer(null, ...args);

_renderSubtreeIntoContainer

React.createElement(TopLevelWrapper, {child: nextElement})
    this.rootID = 1
    render: return this.props.child
</code></pre><h1 id="inject-src-renderers-dom-stack-client-ReactDOMStackInjection-js"><a href="#inject-src-renderers-dom-stack-client-ReactDOMStackInjection-js" class="headerlink" title="inject(./src/renderers/dom/stack/client/ReactDOMStackInjection.js)"></a>inject(./src/renderers/dom/stack/client/ReactDOMStackInjection.js)</h1><pre><code>初始化
</code></pre><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><pre><code>ReactMount.render(jsx, dom);
React.createElement(TopLevelWrapper, {child: jsx})
    type = TopLevelWrapper
    props.child = jsx
    childrenLength = 0;
    return ReactElement(type, null, null, null, null, ReactCurrentOwner.current, {child: jsx})

    ReactElement
        element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: TopLevelWrapper
            key: null,
            ref: null,
            props: {child: jsx}
        }
        return element

nextWrappedElement = element
prevComponent = getTopLevelWrapperInContainer(dom)    //div nodeType is 1 
    dom.firstChild == null
prevComponent = null

reactRootElement = null
containerHasReactMarkup = false
containerHasNonRootReactChild = undefined

shouldReuseMarkup = false

component = ReactMount._renderNewRootComponent(nextWrappedElement, container, false, null, null)
            ._renderedComponent.getPublicInstance()

    componentInstance = instantiateReactComponent(element, false)
            instance = new ReactCompositeComponentWrapper(element); = this.construct(element);

            construct in ReactCompositeComponent(.src/renderers/shared/stack/reconciler/ReactCompositeComponent.js)
            instance._currentElement = element
            instance._rootNodeID = 0
            instance._mountOrder = 0
            instance._mountIndex = 0
            instance._mountImage = null

            return instance

    ReactUpdates.batchedUpdates(            //(./src/renderers/shared/stack/reconciler/ReactUpdates.js)
      batchedMountComponentIntoNode,    //function
      componentInstance,    //instance
      container,            //dom
      shouldReuseMarkup,    //false
      context                //null
    );

        function batchedUpdates(callback, a, b, c, d, e) {
          ensureInjected();
          return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
        }

        var ReactDefaultBatchingStrategy = {
          isBatchingUpdates: false,

          /**
           * Call the provided function in a context within which calls to `setState`
           * and friends are batched such that components aren&apos;t updated unnecessarily.
           */
          batchedUpdates: function(callback, a, b, c, d, e) {
            var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

            ReactDefaultBatchingStrategy.isBatchingUpdates = true;

            // The code is written this way to avoid extra allocations
            if (alreadyBatchingUpdates) {
              return callback(a, b, c, d, e);
            } else {
              return transaction.perform(callback, null, a, b, c, d, e);
            }
          },
        };

    batchedMountComponentIntoNode(instance, dom, false, null)
        transaction = ReactUpdates.ReactReconcileTransaction.getPooled(true)
            getPooled = oneArgumentPooler
                return new this(true) = new ReactReconcileTransaction(true)
                    this.reinitializeTransaction();
                        this.transactionWrappers = this.getTransactionWrappers();
                        this.wrapperInitData = [];
                        this._isInTransaction = false;
                    this.renderToStaticMarkup = false;
                    this.reactMountReady = CallbackQueue.getPooled(null);    = new CallbackQueue()
                    this.useCreateElement = useCreateElement; = true;

        transaction.perform(
            mountComponentIntoNode,        //function
            null,
            componentInstance,            //instance
            container,                    //dom
            transaction,                //
            shouldReuseMarkup,            //false
            context                        //null
        );
            perform: function (method, scope, a, b, c, d, e, f) 
                transaction._isInTransaction = true
                this.initializeAll(0)
                method.call(null, ...args) = mountComponentIntoNode
            function mountComponentIntoNode(wrapperInstance, container, transaction,shouldReuseMarkup,context)
                var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, 
                    ReactDOMContainerInfo(wrapperInstance, container), false, null)
                        ReactDomContainerInfo = info = {
                            _topLevelWrapper: topLevelWrapper,    //wrapperInstance
                            _idCounter: 1,
                            _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,// node.ownerDocument 
                            _node: node,
                            _tag: node ? node.nodeName.toLowerCase() : null,    //DIV
                            _namespaceURI: node ? node.namespaceURI : null,        //http://www.w3.org/1999/xhtml
                          };

                          var markup = warpperInstance.mountComponent(transaction, null, info, null, 0)
                                      = instance.mountComponent
                                  this._context = null
                                  this._hostParent = null
                                  this._hostContainerInfo = info
                                  this._mountOrder = nextMountID++ = 2

                                  var publicProps = this._currentElement.props;
                                  var publicContext = this._processContext(context);    //emptyObject
                                      var maskedContext = this._maskContext(context);
                                          var Component = this._currentElement.type;
                                          var contextTypes = Component.contextTypes;    //emptyObject

                                  var Component = this._currentElement.type;
                                  var updateQueue = transaction.getUpdateQueue();        
                                      ReactUpdateQueue(./src/renderers/shared/stack/reconciler/ReactUpdateQueue.js)

                                  var doConstruct = shouldConstruct(Component); = true;

                                  var inst = this._constructComponent(true, props, context, updateQueue)
                                      //_constructComponentWithoutOwner
                                      var Component = this._currentElement.type;
                                      return new Component(publicProps, publicContext, updateQueue);
                                          new this._currentElement.type(emptyObject, updateQueue);
                                          new TopLevelWrapper({}, updateQueue);

                                  this._compositeType = ReactCompositeComponentTypes.ImpureClass;
                                  inst.props = publicProps;    
                                inst.context = publicContext;
                                inst.refs = emptyObject;
                                inst.updater = updateQueue;

                                this._instance = inst;
                                ReactInstanceMap.set(inst, this);
                                    inst._reactInternalInstance = this;

                                var initialState = inst.state;    //null
                                if inst.componentWillMount then inst.componentWillMount()
                                if inst._pendingStateQueue then inst.state = this._processPendingState(inst.props, inst.context);

                                markup = this.performInitialMount(
                                    renderedElement,
                                    hostParent,
                                    hostContainerInfo,
                                    transaction,
                                    context
                                );
                                if inst.componentDidMount then transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);

                                if this._pendingCallbacks then this._pendingCallbacks = null &amp; 
                                    transaction.getReactMountReady().enqueue(
                                      callbacks[i],
                                      inst
                                    );
                                return markup


                wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
                ReactMount._mountImageIntoNode(
                    markup,
                    container,
                    wrapperInstance,
                    shouldReuseMarkup,
                    transaction
                );



          ReactUpdates.ReactReconcileTransaction.release(transaction);


    instancesByReactRootID[wrapperID] = componentInstance;
    return componentInstance
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/02/21/react源码阅读/">
    <time datetime="2017-02-21T07:41:27.000Z" class="entry-date">
        2017-02-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-react-redux源码阅读" class="post-react-redux源码阅读 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/02/21/react-redux源码阅读/">react-redux源码阅读</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="wilson-lin1993.github.io/2017/02/21/react-redux源码阅读/" data-id="cizggy3pl0000cve89bppsw7e" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><pre><code>return a component
this componet get redux store
Provider.prototype.componentWillReceiveProps this function get this.store and nextStore = this function arguments[0]
</code></pre><h1 id="connectAdvanced"><a href="#connectAdvanced" class="headerlink" title="connectAdvanced"></a>connectAdvanced</h1><pre><code>the function have two argument, first is selectorFactory, second is selectorFactoryOptions
return    a function; this function return hoistStatics(component class);  WrappedComponent is the child componet;
and use WrappedComponent create new element
this.selector
this.selector = makeSelectorStateful(sourceSelector, this.store)
makeSelectorStateful function return selector, this object only have run function, 
sourceSelector(store.getState, props)
if have change set selector props and shouldComponentUpdate
sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)
</code></pre><h1 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h1><pre><code>use match function to get initMapStateToProps、initMapDispatchToProps、initMergeProps
return connectAdvanced
mapStateToPropsFactories function(./connect/mapStateToProps.js)
each run whenMapDispatchToPropsIsFunction function and so on
wrapMapToPropsFunc function(./connect/wrapMapToProps)

wrapMapToPropsConstant
==
    this function have two arguments, first is mapToProps function, second is methodName
    this function return a function(initProxySelector), this function have two argument, first dispatch, second {dispatchName}
    the return function return a function(proxy)
    proxy = proxy.mapToProps(stateOrDispatch, ownProps)
    proxy.mapToProps is detectFactoryAndVerify function
    set proxy.mapToProps as the last mapToProps, boolean(proxy.dependsOnOwnProps)
    and use proxy function to get the props, the new proxy run the last mapToProps
    if the last mapToProps return a function, set proxy.mapToProps = props and use the proxy to get props again
    verifyPlainObject(props, displayName, methodName)
    return proxy
wrapMapToPropsConstant
==
    this function have a argument is getConstant
    return a function(constantSelector) this function return {} //getConstant(dispatch, options)

selectorFactory(./connect/selectorFactory.js)
===
    mapStateToProps = initMapStateToProps(dispatch, options)

    pureFinalPropsSelectorFactory
    first run handleFirstCall
    last run handleSubsequentCalls
    后面再看。。。

    handleSubsequentCalls
    ==
        监听state or props变化
</code></pre><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><pre><code>Subscription(./utils/Subscription.js)
===

verifyPlainObject(./utils/verifyPlainObject.js)
===
    isPlainObject(value), if false then warning

isPlainObject
===
    是否是一个普通的对象
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/02/21/react-redux源码阅读/">
    <time datetime="2017-02-21T07:01:24.000Z" class="entry-date">
        2017-02-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-redux源码阅读" class="post-redux源码阅读 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/02/21/redux源码阅读/">redux源码阅读</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="wilson-lin1993.github.io/2017/02/21/redux源码阅读/" data-id="cizggy3pp0001cve8gr8bjspc" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h1><h1 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h1><pre><code>该方法接受三个参数, reducer, preloadedState, enhancer
第三个参数即生成的中间件函数，如果不为空，则调用这个函数

该创建函数存储reducer方法、初始化数据
store对象使用currentState存储state， currentReducer存储reducer
currentListeners用来存储listener方法，即currentState发生变化时要通知的监听函数
ensureCanMutateNextListeners、subscribe这两个方法都是用来处理listeners

store.dispatch方法调用currentReducer方法， 并在获得新的currentState后执行监听方法
如果有中间件，则store.dispatch作为包装后的dispatch方法的最后一层
</code></pre><h1 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h1><h1 id="合并reducer"><a href="#合并reducer" class="headerlink" title="合并reducer"></a>合并reducer</h1><pre><code>该方法接受reducers对象，使用key来作为新对象的key，该合并方法将返回一个combination方法
该方法用来接受dispatch方法，即store.dispatch方法调用

其中关键部分代码
for (let i = 0; i &lt; finalReducerKeys.length; i++) {
  const key = finalReducerKeys[i]
  const reducer = finalReducers[key]
  const previousStateForKey = state[key]
  const nextStateForKey = reducer(previousStateForKey, action)
  if (typeof nextStateForKey === &apos;undefined&apos;) {
    const errorMessage = getUndefinedStateErrorMessage(key, action)
    throw new Error(errorMessage)
  }
  nextState[key] = nextStateForKey
  hasChanged = hasChanged || nextStateForKey !== previousStateForKey
}
循环执行reducer方法，并将返回的state结果存储在key对应的nextState中
最后返回这个nextState
</code></pre><h1 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h1><h1 id="绑定action构造方法"><a href="#绑定action构造方法" class="headerlink" title="绑定action构造方法"></a>绑定action构造方法</h1><pre><code>function bindActionCreator(actionCreator, dispatch) {
      return (...args) =&gt; dispatch(actionCreator(...args))
}
执行action构建方法

for (let i = 0; i &lt; keys.length; i++) {
    const key = keys[i]
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === &apos;function&apos;) {
          boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  过滤非function类型的参数，同时使用boundActionCreators数组来存储生成的dispatch方法
</code></pre><h1 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h1><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><pre><code>applyMiddleware方法用来生成中间件
返回一个方法，该方法接受一个参数，为createStore方法， 该方法将在执行createStore时进行判断，如果存在中间件，则执行这个applyMiddleware生成的方法，并将createStore作为参数传入
const store = createStore(reducer, preloadedState, enhancer)
首先调用createStore创建一个store
let dispatch = store.dispatch
这里的dispatch是store默认的dispatch
中间件接受两个参数， 分别是getState和dispatch
const middlewareAPI = {
  getState: store.getState,
  dispatch: (action) =&gt; dispatch(action)
}
store.getState 获取store存储的state

接下来使用chain存储中间件方法第一次执行的结果，每个中间件都会返回一个方法
附一段中间件方法
function earlyDispatch({ dispatch }) {
  dispatch(addTodo(&apos;Hello&apos;))
  return () =&gt; action =&gt; action
}

接着使用compose生成middlewares的连续执行方法（越后面越先执行)
</code></pre><h1 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h1><h1 id="合并中间件方法"><a href="#合并中间件方法" class="headerlink" title="合并中间件方法"></a>合并中间件方法</h1><pre><code>这部分代码很简单，主要语句
funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
通过reduce循环执行中间件方法，从后往前执行，其中b为前一次（即后面一个）的中间件方法
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/02/21/redux源码阅读/">
    <time datetime="2017-02-21T04:50:09.000Z" class="entry-date">
        2017-02-21
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redux-源码/">redux 源码</a></li></ul>

    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2017/02/21/react源码阅读/">react源码阅读</a>
          </li>
        
          <li>
            <a href="/2017/02/21/react-redux源码阅读/">react-redux源码阅读</a>
          </li>
        
          <li>
            <a href="/2017/02/21/redux源码阅读/">redux源码阅读</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/redux-源码/">redux 源码</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/redux-源码/" style="font-size: 10px;">redux 源码</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2017 Wilson
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>