<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>说书人</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="说书人">
<meta property="og:url" content="wilson-lin1993.github.io/index.html">
<meta property="og:site_name" content="说书人">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="说书人">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="说书人" rel="home">说书人</a>
      </h1>
      

      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-react-sage教程" class="post-react-sage教程 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/03/02/react-sage教程/">react-sage教程</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="wilson-lin1993.github.io/2017/03/02/react-sage教程/" data-id="cj36mvemq0002186d1m048wt4" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="desc"><a href="#desc" class="headerlink" title="desc"></a>desc</h2><pre><code>一个用来替代react-thunk的库， 异步调用action
</code></pre><h2 id="takeEvery"><a href="#takeEvery" class="headerlink" title="takeEvery"></a>takeEvery</h2><pre><code>deprecate(takeEveryHelper, deprecationWarning(&apos;takeEvery&apos;))
=    takeEveryHelper(...args)
takeEveryHelper
---
    function(patternOrChannel, worker, ...args)
    patternOrChannel maybe a name string, worker is a async function
        const yTake = {done: false, value: take(patternOrChannel)}
        const yFork = ac =&gt; ({done: false, value: fork(worker, ...args, ac)})
        //create generator function
        let action, setAction = ac =&gt; action = ac
        return fsmIterator({
            q1() { return [&apos;q2&apos;, yTake, setAction] },
            q2() { return action === END ? [qEnd] : [&apos;q1&apos;, yFork(action)] }
                //END = {type: CHANNEL_END_TYPE} = {type: &apos;@@redux-saga/CHANNEL_END&apos;}
        }, &apos;q1&apos;, `takeEvery(${safeName(patternOrChannel)}, ${worker.name})`)
</code></pre><h2 id="fsmIterator-qEnd"><a href="#fsmIterator-qEnd" class="headerlink" title="fsmIterator        //qEnd = {}"></a>fsmIterator        //qEnd = {}</h2><pre><code>function(fsm, q0, name = &apos;iterator&apos;)
let updateState, qNext = q0
function next(arg, error)
    if qNext === qEnd //执行到最后一个next方法
        return done
    updateState &amp;&amp; updateState(arg)    //执行updateState方法
    let [q, output, _updateState] = fsm[qNext]()
        //fsm[qNext] = fsm[&apos;q1&apos;] = function return [&apos;q2&apos;, yTake, setAction]
    qNext = q //next 方法 &apos;q2&apos;
    updateState = _updateState //updateState 方法也等于上一个方法返回的方法
                                // setAction
    return qNext === qEnd ? done : output //如果结束返回done, 否则返回output
                                //return yTake

return makeIterator(next, error function, name, true)
    = {name, next, error, return: KReturn}
</code></pre><h2 id="makeIterator"><a href="#makeIterator" class="headerlink" title="makeIterator"></a>makeIterator</h2><pre><code>function(next, thro, name, isHelper)
const iterator = {name, next, throw: thro, return: kReturn}
    KReturn is a return next obj function
    const kReturn = value =&gt; ({value, done: true})

iterator[HELPER] = true // HELPER = sym(&apos;HELPER&apos;) //@@redux-saga/HELPER
    sym = id =&gt; `@@redux-saga/${id}`

iterator[Symbol.iterator] = () =&gt; iterator  //做个缓存，如果支持Symbol
return iterator
</code></pre><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><pre><code>function(fn, ...args)
effect(FORK, getFnCallDesc(&apos;fork&apos;, fn, args))
getFnCallDesc
---
    check(fn, is.notUndef, warn string)
    if(is.array(fn)) {
        [context, fn] = fn
    } else if(fn.fn) {
        ({context, fn} = fn)
    }
    check(fn,is.func, warn string)
    return {context, fn, args}

effect
---
    function(type, payload)
    return ({[IO]: true, [type]: payload})
        //sym(&apos;IO&apos;)
        ({[sym[&apos;IO&apos;]: true, [&apos;FORK&apos;]: {context, fn, args}]})
    example
    ---
        type = FORK = &apos;FORK&apos;
        payload = {context, fn, args}
            //{context, fn} = fn = worker = async function
</code></pre><h2 id="check"><a href="#check" class="headerlink" title="check"></a>check</h2><pre><code>function(value, predicate, warn string)
isn&apos;t predicate(value)? then
    warn
</code></pre><h2 id="deprecate"><a href="#deprecate" class="headerlink" title="deprecate"></a>deprecate</h2><pre><code>function(fn, deprecationWarning)
return a function, this function run fn(...args)
</code></pre><h2 id="deprecationWarning"><a href="#deprecationWarning" class="headerlink" title="deprecationWarning"></a>deprecationWarning</h2><pre><code>this function is create warning string with helperName
</code></pre><h2 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h2><pre><code>return new Promise function
    this function setTimeout run resolve()
</code></pre><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><pre><code>function(channel, action)
check channel is notUndef &amp;&amp; channel
check action is notUndef
return effect(PUT, {channel, action})
    //({[sym[&apos;IO&apos;]: true, [&apos;PUT&apos;]: {channel, action}]})
    // 
</code></pre><h2 id="createSagaMiddleware-sagaMiddlewareFactory"><a href="#createSagaMiddleware-sagaMiddlewareFactory" class="headerlink" title="createSagaMiddleware //sagaMiddlewareFactory"></a>createSagaMiddleware //sagaMiddlewareFactory</h2><pre><code>let runSagaDynamically
  const {sagaMonitor} = options

  sageMiddleware function ({getState, dispatch})    //redux applyMiddleware function
      runSagaDynamically = runSaga
    const sagaEmitter = emitter()
    sagaEmitter.emit = (options.emitter || ident)(sagaEmitter.emit)
    const sagaDispatch = wrapSagaDispatch(dispatch)
        //return function(dispatch) 
            const wrappedAction = Object.defineProperty(action, SAGA_ACTION, { value: true })
                action.sym(&apos;SAGA_ACTION&apos;) = { value: true }
                wrappedAction = action
            return dispatch(wrappedAction)
    function runSaga(saga, args, sagaId) {
      return proc(
        saga(...args),
        sagaEmitter.subscribe,
        sagaDispatch,
        getState,
        options,
        sagaId,
        saga.name
      )
    }
    return next =&gt; action =&gt; {
      if(sagaMonitor) {
        sagaMonitor.actionDispatched(action)
      }
      const result = next(action) // hit reducers
      sagaEmitter.emit(action)    //循环执行 subscribes 方法
      return result
    }

  sagaMiddleware.run = (sage, ...args) function
      const effectId = nextSagaId()
    if(sagaMonitor) {
      sagaMonitor.effectTriggered({effectId , root: true, parentEffectId: 0, effect: {root: true, saga, args}})
    }
    const task = runSagaDynamically(saga, args, effectId)
        //runSaga(sage, args, effectId)
        // return proc(sage(...args), subscribe function//添加sub, ...)
    if(sagaMonitor) {
      sagaMonitor.effectResolved(effectId, task)
    }
    return task

  return sagaMiddleware
</code></pre><h2 id="emitter"><a href="#emitter" class="headerlink" title="emitter"></a>emitter</h2><pre><code>return two function
    {
        subscribe,
        emit
    }

subscribe
---
    subscribers.push(sub)
    return remove sub function
emit
---
    emit function(item)
    run each subscribers function with (item)
        subscribers[i](item)
</code></pre><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><pre><code>function(iterator, subscribe, dispatch, getState, options, parentEffectId, name, cont)
const {sagaMonitor, logger, onError} = options
  const log = logger || _log
  const stdChannel = _stdChannel(subscribe)
      //stdChannel(subscribe)

  next.cancel = noop
  return task = new Task(parentEffectId, name, iterator, cont)
  const mainTask = {name, cancel: cancelMain, isRunning: true}
  const taskQueue = forkQueue(name, mainTask, end)
</code></pre><h2 id="stdChannel"><a href="#stdChannel" class="headerlink" title="stdChannel"></a>stdChannel</h2><pre><code>function(subscribe)
return {
...chan,
take(cb, matcher) {
  if(arguments.length &gt; 1) {
    check(matcher, is.func, &apos;channel.take\&apos;s matcher argument must be a function&apos;)
    cb[MATCH] = matcher
  }
  chan.take(cb)
}
</code></pre><p>  }</p>
<h2 id="chan-function"><a href="#chan-function" class="headerlink" title="  chan function"></a>  chan function</h2><pre><code>  eventChannel(cb =&gt; subscribe(input =&gt; {
    if (input[SAGA_ACTION]) {
      cb(input)
      return
    }
    asap(() =&gt; cb(input))
}))

eventChannel function(subscribe) //subscribe = cb =&gt; subscribe(input ...) a new subscribe function
---
    return {
        take: chan.take,
        flush: chan.flush,
        close: () =&gt; {
            chan.close()        //清空takers， 并执行takers each function with (END)
            unsubscribe()
    }
    taskers 一个有限长度的存储空间 buffer， 从头到尾存取的循环队列
    chan.take function(cb)        //取出头数据
        takers.push(cb)
          cb.cancel = () =&gt; remove(takers, cb)
      chan.flush function(cb)        //取出所有数据，清空队列
          cb(buffer.flush())
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/03/02/react-sage教程/">
    <time datetime="2017-03-02T03:37:35.000Z" class="entry-date">
        2017-03-02
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-mobx源码阅读" class="post-mobx源码阅读 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/03/02/mobx源码阅读/">mobx源码阅读</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="wilson-lin1993.github.io/2017/03/02/mobx源码阅读/" data-id="cj36mvemj0000186dw1r0aitn" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h2><pre><code>class Atom extends BaseAtom implements IAtom 
    reportObserved
    ---
        startBatch();
        BaeAtom.reportObserved(); == reportObserved(this);

        if !this.isBeingTracked
            this.isBeingTracked = true;
            this.onBecomeObservedHandler(); //noop();

        endBatch();
        return !!globalState.trackingDerivation;

    reportChanged
    ---
        startBatch();
        propagateChanged(this);
        endBatch();
</code></pre><p>propagateChanged, reportObserved, startBatch, endBatch</p>
<h2 id="in-observable"><a href="#in-observable" class="headerlink" title="in observable"></a>in observable</h2><pre><code>startBatch
---
    globalState.inBatch++;

endBatch
---
    globalState.inBatch--;
    if inBatch === 0 then
        runReactions();
        const list = globalState.pendingUnobservations;
            const observable = list[i];
            observable.isPendingUnobservation = false;
            if (observable.observers.length === 0) {
                observable.onBecomeUnobserved();
                // NOTE: onBecomeUnobserved might push to `pendingUnobservations`
            }
        globalState.pendingUnobservations = [];

reportObserved
---
    function(observable)
    const derivation = globalState.trackingDerivation;
    if derivation !== null then
        if derivation.runId !== observable.lastAccessedBy
            observable.lastAccessedBy = derivation.runId;
            derivation.newObserving![derivation.unboundDepsCount++] = observable;
    else if observable.observers.length === 0  then
        queueForUnobservation(observable);

propagateChanged
---
    function(observable)
    if (observable.lowestObserverState === IDerivationState.STALE) return;
    observable.lowestObserverState = IDerivationState.STALE;

    const observers = observable.observers;
    let i = observers.length;
    while (i--) {
        const d = observers[i];
        if (d.dependenciesState === IDerivationState.UP_TO_DATE)
            d.onBecomeStale();
        d.dependenciesState = IDerivationState.STALE;
    }
</code></pre><h2 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h2><pre><code>track
---
    function(fn)
    startBatch();

    this._isRunning = true;
    const result = trackDerivedFunction(this, fn, undefined);
    this._isRunning = false;
    this._isTrackPending = false;

    if (isCaughtException(result))
        this.reportExceptionInDerivation(result.cause);

    endBatch();

dispose
---
    //如果发生错误
    clearObserving(this);

runReactions
---
    if (globalState.inBatch &gt; 0 || globalState.isRunningReactions)
        return;
    reactionScheduler(runReactionsHelper);
</code></pre><h2 id="trackDerivedFunction"><a href="#trackDerivedFunction" class="headerlink" title="trackDerivedFunction"></a>trackDerivedFunction</h2><pre><code>function(derivation, context)

changeDependenciesStateTo0(derivation);
derivation.newObserving = new Array(derivation.observing.length + 100);
derivation.unboundDepsCount = 0;
derivation.runId = ++globalState.runId;
const prevTracking = globalState.trackingDerivation;
globalState.trackingDerivation = derivation;
let result;
try {
    result = f.call(context);
} catch (e) {
    result = new CaughtException(e);
}
globalState.trackingDerivation = prevTracking;
bindDependencies(derivation);
return result;
</code></pre><h2 id="changeDependenciesStateTo0"><a href="#changeDependenciesStateTo0" class="headerlink" title="changeDependenciesStateTo0"></a>changeDependenciesStateTo0</h2><pre><code>function(derivation)
if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;
derivation.dependenciesState = IDerivationState.UP_TO_DATE;

const obs = derivation.observing;
let i = obs.length;
while (i--)
    obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;
</code></pre><h2 id="bindDependencies"><a href="#bindDependencies" class="headerlink" title="bindDependencies"></a>bindDependencies</h2><pre><code>const prevObserving = derivation.observing;
const observing = derivation.observing = derivation.newObserving!;

derivation.newObserving = null; // newObserving shouldn&apos;t be needed outside tracking

// Go through all new observables and check diffValue: (this list can contain duplicates):
//   0: first occurence, change to 1 and keep it
//   1: extra occurence, drop it
let i0 = 0, l = derivation.unboundDepsCount;
for (let i = 0; i &lt; l; i++) {
    const dep = observing[i];
    if (dep.diffValue === 0) {
        dep.diffValue = 1;
        if (i0 !== i) observing[i0] = dep;
        i0++;
    }
}
observing.length = i0;

// Go through all old observables and check diffValue: (it is unique after last bindDependencies)
//   0: it&apos;s not in new observables, unobserve it
//   1: it keeps being observed, don&apos;t want to notify it. change to 0
l = prevObserving.length;
while (l--) {
    const dep = prevObserving[l];
    if (dep.diffValue === 0) {
        removeObserver(dep, derivation);
    }
    dep.diffValue = 0;
}

// Go through all new observables and check diffValue: (now it should be unique)
//   0: it was set to 0 in last loop. don&apos;t need to do anything.
//   1: it wasn&apos;t observed, let&apos;s observe it. set back to 0
while (i0--) {
    const dep = observing[i0];
    if (dep.diffValue === 1) {
        dep.diffValue = 0;
        addObserver(dep, derivation);
    }
}
</code></pre><h2 id="observale"><a href="#observale" class="headerlink" title="observale"></a>observale</h2><pre><code>=createObservable(v)
    if (typeof arguments[1] === &quot;string&quot;)
        return deepDecorator.apply(null, arguments);

    invariant(arguments.length &lt;= 1, getMessage(&quot;m021&quot;));
    invariant(!isModifierDescriptor(v), getMessage(&quot;m020&quot;));

    if (isObservable(v))
        return v;
    const res = deepEnhancer(v, undefined, undefined);
    if (res !== v)
        return res;
    return observable.box(v)

    box
    ---
        if (arguments.length &gt; 2)
            incorrectlyUsedAsDecorator(&quot;box&quot;);    //error
        return new ObservableValue(value, deepEnhancer, name);

    ObservableValue
    ---
        class ObservableValue extends BaseAtom
            super(name)    // name = &quot;ObservableValue@&quot; + getNextId()
            this.value = value
</code></pre><h2 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a>autorun</h2><pre><code>function(view, scope)
    if (scope)
        view = view.bind(scope);
    const reaction = new Reaction(name, function () {
        this.track(reactionRunner);
    });
    reaction.schedule();

    return reaction.getDisposer();

    reactionRunner
    ---
        view(reaction);    

//绑定自动执行函数， 该函数每次变化（或读取？）数值时执行
//该函数有一个参数，为reaction函数
</code></pre><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><pre><code>if @computed function then
    return computedDecorator(class, key)

else?    //以后再看

computedDecorator = createComputedDecorator(false) = createClassPropertyDecorator(fn1, fn2, fn3)

fn2 = get function(name)
---
    observale = this.$mobx.values[name]
    return observable.get();

f3 = set function(name, value)
---
    this.$mobx.values[name].set(value);
</code></pre><h2 id="createClassPropertyDecorator"><a href="#createClassPropertyDecorator" class="headerlink" title="createClassPropertyDecorator"></a>createClassPropertyDecorator</h2><pre><code>function(onInitialize, get, set)
    return classPropertyDecorator function
        if !descriptor then //如果装饰啟没有第三个参数
            target.get = get
            target.set = set

            target.get &amp; set function() {
                if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true)
                    typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);
                get() || set()
            }
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/03/02/mobx源码阅读/">
    <time datetime="2017-03-02T03:21:54.000Z" class="entry-date">
        2017-03-02
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-react源码阅读" class="post-react源码阅读 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/02/21/react源码阅读/">react源码阅读</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="wilson-lin1993.github.io/2017/02/21/react源码阅读/" data-id="cj36mvems0003186d0mz4jo3c" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="version-16-0-0-alpha-2"><a href="#version-16-0-0-alpha-2" class="headerlink" title="version: 16.0.0-alpha.2"></a>version: 16.0.0-alpha.2</h1><h1 id="ReactComponent-src-iscomorphic-modern-class-ReactBaseClasses-js"><a href="#ReactComponent-src-iscomorphic-modern-class-ReactBaseClasses-js" class="headerlink" title="ReactComponent(./src/iscomorphic/modern/class/ReactBaseClasses.js)"></a>ReactComponent(./src/iscomorphic/modern/class/ReactBaseClasses.js)</h1><pre><code>constructor(props, context, updater)
    this.refs = emptyObject
</code></pre><h1 id="ReactElement-src-isomorphic-classic-element-ReactElement-js"><a href="#ReactElement-src-isomorphic-classic-element-ReactElement-js" class="headerlink" title="ReactElement(./src/isomorphic/classic/element/ReactElement.js)"></a>ReactElement(./src/isomorphic/classic/element/ReactElement.js)</h1><pre><code>createElement
==
</code></pre><h1 id="ReactDom-src-renderers-ReactDOM-js"><a href="#ReactDom-src-renderers-ReactDOM-js" class="headerlink" title="ReactDom(./src/renderers/ReactDOM.js)"></a>ReactDom(./src/renderers/ReactDOM.js)</h1><h1 id="ReactMount-src-renderers-dom-stack-client-ReactMount-js"><a href="#ReactMount-src-renderers-dom-stack-client-ReactMount-js" class="headerlink" title="ReactMount(./src/renderers/dom/stack/client/ReactMount.js)"></a>ReactMount(./src/renderers/dom/stack/client/ReactMount.js)</h1><pre><code>render:
    return ReactMount._renderSubtreeIntoContainer(null, ...args);

_renderSubtreeIntoContainer

React.createElement(TopLevelWrapper, {child: nextElement})
    this.rootID = 1
    render: return this.props.child
</code></pre><h1 id="inject-src-renderers-dom-stack-client-ReactDOMStackInjection-js"><a href="#inject-src-renderers-dom-stack-client-ReactDOMStackInjection-js" class="headerlink" title="inject(./src/renderers/dom/stack/client/ReactDOMStackInjection.js)"></a>inject(./src/renderers/dom/stack/client/ReactDOMStackInjection.js)</h1><pre><code>初始化
</code></pre><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><pre><code>ReactMount.render(jsx, dom);
React.createElement(TopLevelWrapper, {child: jsx})
    type = TopLevelWrapper
    props.child = jsx
    childrenLength = 0;
    return ReactElement(type, null, null, null, null, ReactCurrentOwner.current, {child: jsx})

    ReactElement
        element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: TopLevelWrapper
            key: null,
            ref: null,
            props: {child: jsx}
        }
        return element

nextWrappedElement = element
prevComponent = getTopLevelWrapperInContainer(dom)    //div nodeType is 1 
    dom.firstChild == null
prevComponent = null

reactRootElement = null
containerHasReactMarkup = false
containerHasNonRootReactChild = undefined

shouldReuseMarkup = false

component = ReactMount._renderNewRootComponent(nextWrappedElement, container, false, null, null)
            ._renderedComponent.getPublicInstance()
                _renderedComponent = child = instance
                instance.getPublicInstance function
                    return this._instance = new TopLevelWrapper({}, updateQueue)

    componentInstance = instantiateReactComponent(element, false)
            instance = new ReactCompositeComponentWrapper(element); = this.construct(element);

            construct in ReactCompositeComponent(.src/renderers/shared/stack/reconciler/ReactCompositeComponent.js)
            instance._currentElement = element
            instance._rootNodeID = 0
            instance._mountOrder = 0
            instance._mountIndex = 0
            instance._mountImage = null

            return instance

    ReactUpdates.batchedUpdates(            //(./src/renderers/shared/stack/reconciler/ReactUpdates.js)
      batchedMountComponentIntoNode,    //function
      componentInstance,    //instance
      container,            //dom
      shouldReuseMarkup,    //false
      context                //null
    );

        function batchedUpdates(callback, a, b, c, d, e) {
          ensureInjected();
          return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
        }

        var ReactDefaultBatchingStrategy = {
          isBatchingUpdates: false,

          /**
           * Call the provided function in a context within which calls to `setState`
           * and friends are batched such that components aren&apos;t updated unnecessarily.
           */
          batchedUpdates: function(callback, a, b, c, d, e) {
            var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

            ReactDefaultBatchingStrategy.isBatchingUpdates = true;

            // The code is written this way to avoid extra allocations
            if (alreadyBatchingUpdates) {
              return callback(a, b, c, d, e);
            } else {
              return transaction.perform(callback, null, a, b, c, d, e);
            }
          },
        };

    batchedMountComponentIntoNode(instance, dom, false, null)
        transaction = ReactUpdates.ReactReconcileTransaction.getPooled(true)
            getPooled = oneArgumentPooler
                return new this(true) = new ReactReconcileTransaction(true)
                    this.reinitializeTransaction();
                        this.transactionWrappers = this.getTransactionWrappers();
                        this.wrapperInitData = [];
                        this._isInTransaction = false;
                    this.renderToStaticMarkup = false;
                    this.reactMountReady = CallbackQueue.getPooled(null);    = new CallbackQueue()
                    this.useCreateElement = useCreateElement; = true;

        transaction.perform(
            mountComponentIntoNode,        //function
            null,
            componentInstance,            //instance
            container,                    //dom
            transaction,                //
            shouldReuseMarkup,            //false
            context                        //null
        );
            perform: function (method, scope, a, b, c, d, e, f) 
                transaction._isInTransaction = true
                this.initializeAll(0)
                method.call(null, ...args) = mountComponentIntoNode
            function mountComponentIntoNode(wrapperInstance, container, transaction,shouldReuseMarkup,context)
                var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, 
                    ReactDOMContainerInfo(wrapperInstance, container), false, null)
                        ReactDomContainerInfo = info = {
                            _topLevelWrapper: topLevelWrapper,    //wrapperInstance
                            _idCounter: 1,
                            _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,// node.ownerDocument 
                            _node: node,
                            _tag: node ? node.nodeName.toLowerCase() : null,    //DIV
                            _namespaceURI: node ? node.namespaceURI : null,        //http://www.w3.org/1999/xhtml
                          };

                          var markup = warpperInstance.mountComponent(transaction, null, info, null, 0)
                                      = instance.mountComponent
                                  this._context = null
                                  this._hostParent = null
                                  this._hostContainerInfo = info
                                  this._mountOrder = nextMountID++ = 2

                                  var publicProps = this._currentElement.props;
                                  var publicContext = this._processContext(context);    //emptyObject
                                      var maskedContext = this._maskContext(context);
                                          var Component = this._currentElement.type;
                                          var contextTypes = Component.contextTypes;    //emptyObject

                                  var Component = this._currentElement.type;
                                  var updateQueue = transaction.getUpdateQueue();        
                                      ReactUpdateQueue(./src/renderers/shared/stack/reconciler/ReactUpdateQueue.js)

                                  var doConstruct = shouldConstruct(Component); = true;

                                  var inst = this._constructComponent(true, props, context, updateQueue)
                                      //_constructComponentWithoutOwner
                                      var Component = this._currentElement.type;
                                      return new Component(publicProps, publicContext, updateQueue);
                                          new this._currentElement.type(emptyObject, updateQueue);
                                          new TopLevelWrapper({}, updateQueue);

                                  this._compositeType = ReactCompositeComponentTypes.ImpureClass;
                                  inst.props = publicProps;    
                                inst.context = publicContext;
                                inst.refs = emptyObject;
                                inst.updater = updateQueue;

                                this._instance = inst;
                                ReactInstanceMap.set(inst, this);
                                    inst._reactInternalInstance = this;

                                var initialState = inst.state;    //null
                                if inst.componentWillMount then inst.componentWillMount()
                                    this.classNameAndNodeQueue = [];
                                    this.transitionTimeouts = [];
                                if inst._pendingStateQueue then inst.state = this._processPendingState(inst.props, inst.context);
                                    this._pendingStateQueue tran to nextState
                                    return nextState

                                markup = this.performInitialMount(
                                    renderedElement,
                                    hostParent,
                                    hostContainerInfo,
                                    transaction,
                                    context
                                );
                                    renderedElement = this._renderValidatedComponent();
                                    this._renderValidatedComponentWithoutOwnerOrContext();
                                        var inst = this._instance
                                        renderedElement = inst.render();    //TopLevelWrapper.render()
                                                                            //this.props.child //App
                                        return renderedElement
                                    var nodeType = ReactNodeTypes.getType(renderedElement);
                                    this._renderedNodeType = nodeType;
                                    var child = this._instantiateReactComponent(renderedElement,
                                    nodeType !== ReactNodeTypes.EMPTY)
                                        instantiateReactComponent function(/src/renderers/shared/stack/reconciler/instantiateReactComponent.js)
                                        return instance

                                    this._renderedComponent = child

                                    var markup = ReactReconciler.mountComponent(
                                      child,
                                      transaction,
                                      hostParent,
                                      hostContainerInfo,
                                      this._processChildContext(context),
                                      debugID
                                    );

                                        markup = internalInstance.mountComponenet(...args);
                                                = child.mountComponent(...args);
                                                = ReactCompositeComponent.mountComponent
                                                = this page mountComponent
                                            return markup (循环调用？？？)
                                    return markup

                                if inst.componentDidMount then transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
                                    getReactMountReady() =&gt; return this.reactMountReady
                                    enqueue function(./src/renderers/shared/stack/reconciler/ReactMultiChild.js)
                                    inst.componentDidMount.push(inst)

                                if this._pendingCallbacks then this._pendingCallbacks = null &amp; 
                                    transaction.getReactMountReady().enqueue(
                                      callbacks[i],
                                      inst
                                    );
                                return markup


                wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
                ReactMount._mountImageIntoNode(
                    markup,
                    container,
                    wrapperInstance,
                    shouldReuseMarkup,
                    transaction
                );
                return markup



          ReactUpdates.ReactReconcileTransaction.release(transaction);


    instancesByReactRootID[wrapperID] = componentInstance;
    return componentInstance


jsx
    React.createElement(&quot;div&quot;, null)
        return element = {
            type: &quot;div&quot;
        }

instantiateReactComponent(jsx)
    ReactHostComponent.createInternalComponent(element);
        return new genericComponentClass(element);
            new ReactDOMComponent(element)    //(./src/renderers/dom/stack/client/ReactDOMComponent.js)
            this._currentElement = element
            this._tag = &quot;DIV&quot;

        this.mountComponent return mountImage
            el = ownerDocument.createElement(type);
                document.createElement(&quot;div&quot;)

            ReactDOMComponentTree.precacheNode(this, el);
            this._updateDOMProperties(null, props, transaction, isCustomComponentTag);
            var lazyTree = DOMLazyTree(el);
                {node: noe, children: [], html: null, text null, toString}
            this._createInitialChildren(transaction, props, context, lazyTree);

            mountImage ＝ lazyTree
            判断绑定属性 onClick
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/02/21/react源码阅读/">
    <time datetime="2017-02-21T07:41:27.000Z" class="entry-date">
        2017-02-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-react-redux源码阅读" class="post-react-redux源码阅读 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/02/21/react-redux源码阅读/">react-redux源码阅读</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="wilson-lin1993.github.io/2017/02/21/react-redux源码阅读/" data-id="cj36mvemo0001186d82njlnj6" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><pre><code>return a component
this componet get redux store
Provider.prototype.componentWillReceiveProps this function get this.store and nextStore = this function arguments[0]
</code></pre><h1 id="connectAdvanced"><a href="#connectAdvanced" class="headerlink" title="connectAdvanced"></a>connectAdvanced</h1><pre><code>the function have two argument, first is selectorFactory, second is selectorFactoryOptions
return    a function; this function return hoistStatics(component class);  WrappedComponent is the child componet;
and use WrappedComponent create new element
this.selector
this.selector = makeSelectorStateful(sourceSelector, this.store)
makeSelectorStateful function return selector, this object only have run function, 
sourceSelector(store.getState, props)
if have change set selector props and shouldComponentUpdate
sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)
</code></pre><h1 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h1><pre><code>use match function to get initMapStateToProps、initMapDispatchToProps、initMergeProps
return connectAdvanced
mapStateToPropsFactories function(./connect/mapStateToProps.js)
each run whenMapDispatchToPropsIsFunction function and so on
wrapMapToPropsFunc function(./connect/wrapMapToProps)

wrapMapToPropsConstant
==
    this function have two arguments, first is mapToProps function, second is methodName
    this function return a function(initProxySelector), this function have two argument, first dispatch, second {dispatchName}
    the return function return a function(proxy)
    proxy = proxy.mapToProps(stateOrDispatch, ownProps)
    proxy.mapToProps is detectFactoryAndVerify function
    set proxy.mapToProps as the last mapToProps, boolean(proxy.dependsOnOwnProps)
    and use proxy function to get the props, the new proxy run the last mapToProps
    if the last mapToProps return a function, set proxy.mapToProps = props and use the proxy to get props again
    verifyPlainObject(props, displayName, methodName)
    return proxy
wrapMapToPropsConstant
==
    this function have a argument is getConstant
    return a function(constantSelector) this function return {} //getConstant(dispatch, options)

selectorFactory(./connect/selectorFactory.js)
===
    mapStateToProps = initMapStateToProps(dispatch, options)

    pureFinalPropsSelectorFactory
    first run handleFirstCall
    last run handleSubsequentCalls
    后面再看。。。

    handleSubsequentCalls
    ==
        监听state or props变化
</code></pre><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><pre><code>Subscription(./utils/Subscription.js)
===

verifyPlainObject(./utils/verifyPlainObject.js)
===
    isPlainObject(value), if false then warning

isPlainObject
===
    是否是一个普通的对象
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/02/21/react-redux源码阅读/">
    <time datetime="2017-02-21T07:01:24.000Z" class="entry-date">
        2017-02-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-redux源码阅读" class="post-redux源码阅读 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/02/21/redux源码阅读/">redux源码阅读</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="wilson-lin1993.github.io/2017/02/21/redux源码阅读/" data-id="cj36mvems0004186dsrkmgwlp" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h1><h1 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h1><pre><code>该方法接受三个参数, reducer, preloadedState, enhancer
第三个参数即生成的中间件函数，如果不为空，则调用这个函数

该创建函数存储reducer方法、初始化数据
store对象使用currentState存储state， currentReducer存储reducer
currentListeners用来存储listener方法，即currentState发生变化时要通知的监听函数
ensureCanMutateNextListeners、subscribe这两个方法都是用来处理listeners

store.dispatch方法调用currentReducer方法， 并在获得新的currentState后执行监听方法
如果有中间件，则store.dispatch作为包装后的dispatch方法的最后一层
</code></pre><h1 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h1><h1 id="合并reducer"><a href="#合并reducer" class="headerlink" title="合并reducer"></a>合并reducer</h1><pre><code>该方法接受reducers对象，使用key来作为新对象的key，该合并方法将返回一个combination方法
该方法用来接受dispatch方法，即store.dispatch方法调用

其中关键部分代码
for (let i = 0; i &lt; finalReducerKeys.length; i++) {
  const key = finalReducerKeys[i]
  const reducer = finalReducers[key]
  const previousStateForKey = state[key]
  const nextStateForKey = reducer(previousStateForKey, action)
  if (typeof nextStateForKey === &apos;undefined&apos;) {
    const errorMessage = getUndefinedStateErrorMessage(key, action)
    throw new Error(errorMessage)
  }
  nextState[key] = nextStateForKey
  hasChanged = hasChanged || nextStateForKey !== previousStateForKey
}
循环执行reducer方法，并将返回的state结果存储在key对应的nextState中
最后返回这个nextState
</code></pre><h1 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h1><h1 id="绑定action构造方法"><a href="#绑定action构造方法" class="headerlink" title="绑定action构造方法"></a>绑定action构造方法</h1><pre><code>function bindActionCreator(actionCreator, dispatch) {
      return (...args) =&gt; dispatch(actionCreator(...args))
}
执行action构建方法

for (let i = 0; i &lt; keys.length; i++) {
    const key = keys[i]
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === &apos;function&apos;) {
          boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  过滤非function类型的参数，同时使用boundActionCreators数组来存储生成的dispatch方法
</code></pre><h1 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h1><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><pre><code>applyMiddleware方法用来生成中间件
返回一个方法，该方法接受一个参数，为createStore方法， 该方法将在执行createStore时进行判断，如果存在中间件，则执行这个applyMiddleware生成的方法，并将createStore作为参数传入
const store = createStore(reducer, preloadedState, enhancer)
首先调用createStore创建一个store
let dispatch = store.dispatch
这里的dispatch是store默认的dispatch
中间件接受两个参数， 分别是getState和dispatch
const middlewareAPI = {
  getState: store.getState,
  dispatch: (action) =&gt; dispatch(action)
}
store.getState 获取store存储的state

接下来使用chain存储中间件方法第一次执行的结果，每个中间件都会返回一个方法
附一段中间件方法
function earlyDispatch({ dispatch }) {
  dispatch(addTodo(&apos;Hello&apos;))
  return () =&gt; action =&gt; action
}

接着使用compose生成middlewares的连续执行方法（越后面越先执行)
</code></pre><h1 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h1><h1 id="合并中间件方法"><a href="#合并中间件方法" class="headerlink" title="合并中间件方法"></a>合并中间件方法</h1><pre><code>这部分代码很简单，主要语句
funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
通过reduce循环执行中间件方法，从后往前执行，其中b为前一次（即后面一个）的中间件方法
</code></pre>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/02/21/redux源码阅读/">
    <time datetime="2017-02-21T04:50:09.000Z" class="entry-date">
        2017-02-21
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redux-源码/">redux 源码</a></li></ul>

    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2017/03/02/react-sage教程/">react-sage教程</a>
          </li>
        
          <li>
            <a href="/2017/03/02/mobx源码阅读/">mobx源码阅读</a>
          </li>
        
          <li>
            <a href="/2017/02/21/react源码阅读/">react源码阅读</a>
          </li>
        
          <li>
            <a href="/2017/02/21/react-redux源码阅读/">react-redux源码阅读</a>
          </li>
        
          <li>
            <a href="/2017/02/21/redux源码阅读/">redux源码阅读</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/redux-源码/">redux 源码</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/redux-源码/" style="font-size: 10px;">redux 源码</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2017 Wilson
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>